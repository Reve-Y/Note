# C++ 笔记

## 基础部分    
* 数据类型：short int long char 等等，不同系统可能占用的内存大小不一样，可以用sizeof函数测试。**sizeof**函数返回类型或者变量的长度，单位是字节，例 sizeof(int) 或者 sizeof n_int。无符号类型不能存储负数值，但可以增大能存储的最大值，例：short:-32768\~32767,则无符号的版本可以表示的范围是0\~65535。无符号类型溢出时，其值将为范围另一端的极值。可参考http://www.runoob.com/cplusplus/cpp-data-types.html

* 变量初始化：可以用C++的大括号初始化器：int test = {7},其中等号可省略

* 变量名的命名方案：除基本规则外，可以约定一个前缀来表示这个变量的类型，比如b表示bool值，p表示指针，c表示单个字符等。

* true 和 false 都可以通过提升转换为int类型。true被转换为 1 ，false被转换为 0 .

* const限定符用来定义一个常量，定义后不可修改。如果在声明常量时没有提供值，编译会出错。且C++中允许使用const值来声明数组长度。

* float double 和 long double都属于浮点类型。浮点数的E表示法确保数字以浮点格式存储。例如3.54e+4,-5E-2 等等。指数为负数意味着除以10的乘方。也可以这样理解: d.ddE+n 指的是将小数点向右移n位，反之相反。此外，在书写浮点数常量的时候，最好加上后缀，例如L,f 。**浮点常量在默认情况下为double类型**。

* C++对基本类型进行分类，形成了若干个类。类型signed char 、short、int和long统称为符号整形。它们的无符号版本统称为无符号整型；C++11新增了long long 、bool、char、wchar_t、符号整数和无符号整数统称为整形；C++11新增了char16_t和char32_t。float、double和long double统称为浮点型。整数和浮点型统称为算术（arithmetic）类型。

* 全局变量和和局部变量同名时，**可通过域名(::var)在函数中引用到全局变量，不加域名解析则引用局部变量**。C++ 全局变量、局部变量、静态全局变量、静态局部变量的区别:http://www.runoob.com/cplusplus/cpp-variable-scope.html

* 面向行的输入：getline():不是像cin一样只读一个单词。它使用通过回车键输入的换行符来确定输入结尾。**cin.getline(array_name,maxNum):在读取到指定数目的字符（maxNum-1个）或者换行符时停止读取,并且丢弃换行符**。如果此时输入的字符超过了maxNum-1，则会影响到下一次读取。而cin.get()可以与getline的参数相同，但是不会丢弃换行符，**cin.get(Name,Size).get()**即可。

* 共用体与结构体不同的是，共用体也可以存储不同的数据类型，**但只能同时存储其中的一种类型（共用内存）**

* 枚举类型更常被用来定义符号常量。enum{red,green,....} red 值为0，依次后推。定义枚举时可以显式地设置枚举量的值，**后面没有初始化的枚举的量的值将比前面的枚举量大1**。 枚举的取值范围定义如下：首先，要找出上限，需要知道枚举量的最大值，找到大于这个最大值的、最小的2的幂，将它减去1得到的便是取值上限。例，101是最大枚举值，则上限为127。要计算下限，需要知道枚举量的最小值，如果它不小于0，则取值范围的下限为0；否则，采用与寻找上限相同的方式，但加上负号。例最小枚举值为-6，则下限为-7。


### 关于指针   
* \* 运算符被称为**间接值**或**解除引用**运算符，将其运用于指针可以得到该地址存储的值。假设有int型变量update和指向它的指针变量p_update,可以将这两个变量看作同一枚硬币的正反面，变量update表示值，并使用&运算符来获得地址；而p_update表示地址，并使用 \* 来获得值。所以将值赋给 \*p_update 时，update变量的值也会改变。 

* 像是 int\* p1,p2 这样的声明，会声明一个指针 p1 和一个int型变量p2。对每个指针变量名，都需要使用一个* 。  警告：一定要在对指针应用解除引用运算符(\*)之前，将指针初始化为一个确定的、适当的地址。  示例：pointer = (int \*)0xB8000000 :将整数的地址直接赋值给指针在C++并不是合法的，因此**需要强制转换成适当的地址类型** 。

* 使用new来分配内存。指针的用处在于，在运行阶段分配未命名的内存以存储值。这种情况下只能通过指针来访问内存。C++中仍然可以像C一样使用malloc()库函数分配内存，但是有更好的方法：new 运算符来分配。为一个数据对象(可以是结构，也可以是基本类型)获得并指定分配内存的通用格式如下：**typeName \* pointer_name = new typeName**。

* 为什么必须声明指针所指向的数据类型呢？以下是原因之一：地址本身只指出了对象存储地址的开始，而没有指出其指向类型所使用的字节数。例如，用cout打印\*pointer时，cout要知道**读取多少个字节**以及如何解释他们。

* 使用new来分配的内存块通常与常规变量声明分配的内存块不同，常规变量的值被存储在 **栈(stack)** 的内存区域中，而new从被称为 **堆(heap)** 或 **自由存储区(free store)** 的内存区域分配内存。

* 使用new分配内存后，可以使用**delete**运算符来回收内存，使其内存归还给内存池。这将释放指针指向的内存，不会删除指针本身。**一定要配对的使用new 和 delete**,否则将发生内存泄漏。不要尝试释放已经释放的内存块。此外，**不能使用delete来释放声明变量所获得的内存**。例：
   ```
    int jugs = 5;
    int * pi = &jugs;
    delete pi ; //  not allowed , 不是通过new分配的内存。 
   ```

* 使用new创建动态数组(在程序运行时而非编译时创建的数组)，示例`` int * psome = new int[10]; `` **new 运算符将会返回第一个元素的地址**。当使用完毕后，也应该用delete释放他们。格式与之前有所不同：`` delete [] psome; `` 。方括号告诉程序，应释放整个数组而不仅是指针指向的元素。如果使用new时不带方括号，那么使用delete释放时也不带方括号；如果使用new时带方括号，则使用delete时也带方括号。 为数组分配内存的通用格式为：
   ``` 
    type_name * pointer_name = new type_name [num_elements] ; 
    //  pointer_name将指向第一个元素。实际上，也可以使用数组名的方式来使用pointer_name 。
   ```

* 总之，使用new和delete时，应遵守以下规则：   
   * 不要使用delete来释放不是new分配的内存
   * 不要使用delete释放同一个内存块两次
   * 如果使用 new [] 为数组分配内存，则应使用delete [] 来释放。
   * 如果使用new为一个实体分配内存，则应使用delete(没有方括号)来释放。
   * 对空指针应用delete是安全的。
   
* 使用动态数组： 接着上面的示例。psome指向第一个元素，分配的内存也是连续的，那么只要将**指针当作数组名**即可。即psome\[0]、psome\[1]..之类的访问方法。下面一段程序是个例子。   
   ```
  double * p = new double [3] ;
  p[0] = 0.3;
  p[1] = 0.5;
  p[2] = 0.7;
  cout<<" p[1] = "<<p[1]<<endl;   //    将会打印  0.5
  p = p + 1;
  cout<<" p[1] = "<<p[1]<<endl;   //    将会打印  0.7
  delete [] p;                    //    不要忘记释放内存
   ```
   实际可以看出数组名和指针的根本差别：不能修改数组名的值，但是指针是变量，因此可以修改。此外，通常double类型的数组相互间隔8个字节，而将p+1后，它将指向下一个元素的地址，这表明指针算数有一些特别之处。

* 
* 
